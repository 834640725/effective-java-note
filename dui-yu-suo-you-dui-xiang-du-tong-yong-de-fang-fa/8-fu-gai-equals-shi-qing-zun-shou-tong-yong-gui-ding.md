# 8: 覆盖 equals 时请遵守通用规定

## 1.覆盖 equals 后，需要满足的条件

- 1.**类的每个实例本质上都是唯一的**
- 2.**不关心是否提供了“逻辑相等”的测试功能**
- 3.**超类已经覆盖了 equals，从超类继承过来d额行为对于子类也是合适的**
- 4.**类是私有的或者包私有的，可以确定它的 equals 方法永远不会被调用**

## 2.覆盖 equals 方法时要遵守的几个约定

- 1.**自反性**

 > 对于任何非 null 的引用值 x，x.euqals(x) 必须返回 true，
 
- 2.**对称性**

 > 对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 必须返回 true。
 
- 3.**传递性**

 > 对于任何非 null 的引用值 x、y 和 z，如果 x.equals(y) 返回 true，y.equals(z) 也返回 true, 那么 x.equals(z) 也必须返回 true。
 
- 4.**一致性**

 > 对于任何非 null 的引用值 x 和 y，只要 equals 的比较操作在对象中多有的信息都没有被修改，多次调用 x.equals(y) 就会一致的返回 true 或者 false。
 
- 5.**非空性**

 > 所有的对象都不能为 null，为了防止抛出空指针异常。
 
## 3.高效实现 equals 方法的诀窍

- 1.**使用 == 操作符检查“参数是否为这个对象的引用”**

- 2.**使用 instanceof 操作符检查“参数是否为正确的类型“**

- 3.**把参数转换为正确的类型（接2）**

- 4.**对于该类中的每个”关键“域，检查参数中的域是否与该对象中对应的域相匹配**

- 5.**编写完之后，检查是否是对称的，传递的，一致的**

- 6.**覆盖 equals 时，总要覆盖 hashcode**

- 7.**不要企图让 equals 方法过于智能**

- 8.**不要将 equals 声明中的 Object 对象替换为其他的类型**

